I need to implement these things before I can write a book about them!!
* every system of the lambda cube
  * and hindley-milner
  * and the calculus of (co)inductive constructions
    * and something based on cubical TT
    * and something with universe polymorphism
    * and something with insanely dependent types
    * and support for tactics
  * and something with non-trivial subtyping
  * and something with row polymorphism
  * and something with typeclasses/constraints
  * and something with irrelevance (runtime, true irrelevance, prop)
  * and something with iso/equirecursive types?
* a lambda calculus with effects
  * and co-effects
* call-by-push-value
* a linear lambda calculus
  * a *classical* linear lambda calculus
  * something with lifetimes, like Rust
  * and something for a quantum computer, at least in theory
* optimal evaluation
  * and perhaps other varieties of improved evaluation other than just "lazy"
  * and something with proof nets
* a lisp
  * with fexprs and macros
  * and continuations
    * and *delimited* continuations
    * and something based on lambda-mu?
* a prolog
  * and I should implement a solver for a type constraint system with it
* a smalltalk
  * not strictly necessary, but I really ought to know...
  * and of course it should have reflection
* a forth from scratch, but actually *finish* it
* refinement types!


of course, this isn't counting all of the:
* parsing algorithms
* compilers
  * optimizations
* virtual machines
* compilation targets
* features like IDEs, language servers, syntax highlighters, debuggers, fuck fuck fuck
